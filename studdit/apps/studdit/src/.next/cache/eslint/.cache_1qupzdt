[{"C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\app.controller.spec.ts":"1","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\app.controller.ts":"2","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\app.module.ts":"3","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\app.service.spec.ts":"4","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\app.service.ts":"5","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\comments\\comments.controller.spec.ts":"6","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\comments\\comments.controller.ts":"7","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\comments\\comments.module.ts":"8","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\comments\\comments.service.spec.ts":"9","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\comments\\comments.service.ts":"10","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\comments\\dto\\create-comment.dto.ts":"11","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\comments\\dto\\create-nested-comment.dto.ts":"12","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\comments\\schemas\\comment.schema.spec.ts":"13","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\comments\\schemas\\comment.schema.ts":"14","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\friends\\dto\\create-friendship.dto.ts":"15","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\friends\\dto\\delete-friendship.dto.ts":"16","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\friends\\friends.controller.spec.ts":"17","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\friends\\friends.controller.ts":"18","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\friends\\friends.module.ts":"19","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\friends\\friends.service.spec.ts":"20","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\friends\\friends.service.ts":"21","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\middleware\\is-active.middleware.spec.ts":"22","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\middleware\\is-active.middleware.ts":"23","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\middleware\\middleware.module.ts":"24","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\neo4j\\neo4j-config.interface.ts":"25","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\neo4j\\neo4j-transaction.interceptor.ts":"26","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\neo4j\\neo4j.module.ts":"27","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\neo4j\\neo4j.service.spec.ts":"28","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\neo4j\\neo4j.service.ts":"29","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\neo4j\\neo4j.utils.ts":"30","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\threads\\dto\\create-thread.dto.ts":"31","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\threads\\dto\\update-thread.dto.ts":"32","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\threads\\schemas\\threads.schema.spec.ts":"33","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\threads\\schemas\\threads.schema.ts":"34","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\threads\\threads.controller.spec.ts":"35","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\threads\\threads.controller.ts":"36","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\threads\\threads.module.ts":"37","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\threads\\threads.service.spec.ts":"38","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\threads\\threads.service.ts":"39","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\users\\dto\\create-user.dto.ts":"40","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\users\\dto\\delete-user.dto.ts":"41","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\users\\dto\\update-user.dto.ts":"42","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\users\\schemas\\user.schema.spec.ts":"43","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\users\\schemas\\user.schema.ts":"44","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\users\\users.controller.spec.ts":"45","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\users\\users.controller.ts":"46","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\users\\users.module.ts":"47","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\users\\users.service.spec.ts":"48","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\users\\users.service.ts":"49"},{"size":615,"mtime":1702327470599,"results":"50","hashOfConfig":"51"},{"size":280,"mtime":1702327470604,"results":"52","hashOfConfig":"51"},{"size":1879,"mtime":1702327470607,"results":"53","hashOfConfig":"51"},{"size":481,"mtime":1702327470611,"results":"54","hashOfConfig":"51"},{"size":166,"mtime":1702327470613,"results":"55","hashOfConfig":"51"},{"size":1349,"mtime":1702327470615,"results":"56","hashOfConfig":"51"},{"size":8622,"mtime":1702327470618,"results":"57","hashOfConfig":"51"},{"size":1065,"mtime":1702327470619,"results":"58","hashOfConfig":"51"},{"size":509,"mtime":1702327470621,"results":"59","hashOfConfig":"51"},{"size":8487,"mtime":1702327470623,"results":"60","hashOfConfig":"51"},{"size":685,"mtime":1702327470628,"results":"61","hashOfConfig":"51"},{"size":512,"mtime":1702327470630,"results":"62","hashOfConfig":"51"},{"size":2837,"mtime":1702327470632,"results":"63","hashOfConfig":"51"},{"size":1540,"mtime":1702327470636,"results":"64","hashOfConfig":"51"},{"size":473,"mtime":1702327470640,"results":"65","hashOfConfig":"51"},{"size":473,"mtime":1702327470658,"results":"66","hashOfConfig":"51"},{"size":979,"mtime":1702327470671,"results":"67","hashOfConfig":"51"},{"size":2092,"mtime":1702328468296,"results":"68","hashOfConfig":"51"},{"size":823,"mtime":1702327470683,"results":"69","hashOfConfig":"51"},{"size":502,"mtime":1702327470684,"results":"70","hashOfConfig":"51"},{"size":3531,"mtime":1702327470685,"results":"71","hashOfConfig":"51"},{"size":2854,"mtime":1702327470689,"results":"72","hashOfConfig":"51"},{"size":1099,"mtime":1702327470691,"results":"73","hashOfConfig":"51"},{"size":1343,"mtime":1702327470693,"results":"74","hashOfConfig":"51"},{"size":256,"mtime":1702327470695,"results":"75","hashOfConfig":"51"},{"size":932,"mtime":1702327470699,"results":"76","hashOfConfig":"51"},{"size":1669,"mtime":1702327470706,"results":"77","hashOfConfig":"51"},{"size":506,"mtime":1702327470707,"results":"78","hashOfConfig":"51"},{"size":1836,"mtime":1702327470709,"results":"79","hashOfConfig":"51"},{"size":373,"mtime":1702327470711,"results":"80","hashOfConfig":"51"},{"size":675,"mtime":1702327470715,"results":"81","hashOfConfig":"51"},{"size":504,"mtime":1702327470717,"results":"82","hashOfConfig":"51"},{"size":5743,"mtime":1702327470719,"results":"83","hashOfConfig":"51"},{"size":1425,"mtime":1702327470729,"results":"84","hashOfConfig":"51"},{"size":1385,"mtime":1702327470730,"results":"85","hashOfConfig":"51"},{"size":7325,"mtime":1702327470732,"results":"86","hashOfConfig":"51"},{"size":1083,"mtime":1702327470734,"results":"87","hashOfConfig":"51"},{"size":3067,"mtime":1702359617483,"results":"88","hashOfConfig":"51"},{"size":10434,"mtime":1702327470739,"results":"89","hashOfConfig":"51"},{"size":474,"mtime":1702327470742,"results":"90","hashOfConfig":"51"},{"size":305,"mtime":1702327470746,"results":"91","hashOfConfig":"51"},{"size":512,"mtime":1702327470748,"results":"92","hashOfConfig":"51"},{"size":4161,"mtime":1702327470750,"results":"93","hashOfConfig":"51"},{"size":489,"mtime":1702327470755,"results":"94","hashOfConfig":"51"},{"size":970,"mtime":1702359606788,"results":"95","hashOfConfig":"51"},{"size":4381,"mtime":1702327470781,"results":"96","hashOfConfig":"51"},{"size":697,"mtime":1702327470797,"results":"97","hashOfConfig":"51"},{"size":3267,"mtime":1702359596815,"results":"98","hashOfConfig":"51"},{"size":5574,"mtime":1702327470802,"results":"99","hashOfConfig":"51"},{"filePath":"100","messages":"101","suppressedMessages":"102","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1ye81z8",{"filePath":"103","messages":"104","suppressedMessages":"105","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"106","messages":"107","suppressedMessages":"108","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"109","messages":"110","suppressedMessages":"111","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"112","messages":"113","suppressedMessages":"114","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"115","messages":"116","suppressedMessages":"117","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"118"},{"filePath":"119","messages":"120","suppressedMessages":"121","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"122"},{"filePath":"123","messages":"124","suppressedMessages":"125","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"126","messages":"127","suppressedMessages":"128","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"129","messages":"130","suppressedMessages":"131","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"132","messages":"133","suppressedMessages":"134","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"135","messages":"136","suppressedMessages":"137","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"138","messages":"139","suppressedMessages":"140","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"141"},{"filePath":"142","messages":"143","suppressedMessages":"144","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"145","messages":"146","suppressedMessages":"147","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"148","messages":"149","suppressedMessages":"150","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"151","messages":"152","suppressedMessages":"153","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"154"},{"filePath":"155","messages":"156","suppressedMessages":"157","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"158"},{"filePath":"159","messages":"160","suppressedMessages":"161","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"162","messages":"163","suppressedMessages":"164","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"165","messages":"166","suppressedMessages":"167","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"168"},{"filePath":"169","messages":"170","suppressedMessages":"171","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"172","messages":"173","suppressedMessages":"174","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"175"},{"filePath":"176","messages":"177","suppressedMessages":"178","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"179"},{"filePath":"180","messages":"181","suppressedMessages":"182","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"183","messages":"184","suppressedMessages":"185","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"186"},{"filePath":"187","messages":"188","suppressedMessages":"189","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"190"},{"filePath":"191","messages":"192","suppressedMessages":"193","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"194"},{"filePath":"195","messages":"196","suppressedMessages":"197","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"198"},{"filePath":"199","messages":"200","suppressedMessages":"201","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"202","messages":"203","suppressedMessages":"204","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"205","messages":"206","suppressedMessages":"207","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"208","messages":"209","suppressedMessages":"210","errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"211"},{"filePath":"212","messages":"213","suppressedMessages":"214","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"215"},{"filePath":"216","messages":"217","suppressedMessages":"218","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"219"},{"filePath":"220","messages":"221","suppressedMessages":"222","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"223"},{"filePath":"224","messages":"225","suppressedMessages":"226","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"227","messages":"228","suppressedMessages":"229","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"230","messages":"231","suppressedMessages":"232","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"233"},{"filePath":"234","messages":"235","suppressedMessages":"236","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"237","messages":"238","suppressedMessages":"239","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"240","messages":"241","suppressedMessages":"242","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"243","messages":"244","suppressedMessages":"245","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"246"},{"filePath":"247","messages":"248","suppressedMessages":"249","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"250"},{"filePath":"251","messages":"252","suppressedMessages":"253","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"254"},{"filePath":"255","messages":"256","suppressedMessages":"257","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"258"},{"filePath":"259","messages":"260","suppressedMessages":"261","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"262","messages":"263","suppressedMessages":"264","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"265"},{"filePath":"266","messages":"267","suppressedMessages":"268","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"269"},"C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\app.controller.spec.ts",[],[],"C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\app.controller.ts",[],[],"C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\app.module.ts",[],[],"C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\app.service.spec.ts",[],[],"C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\app.service.ts",[],[],"C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\comments\\comments.controller.spec.ts",["270","271","272","273","274","275"],[],"import { Test, TestingModule } from '@nestjs/testing';\nimport { CommentsController } from './comments.controller';\nimport { CommentsService } from './comments.service';\nimport { getModelToken } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\n\nimport { Thread } from '../threads/schemas/threads.schema';\nimport { User } from '../users/schemas/user.schema';\nimport { Comment } from './schemas/comment.schema';\n\ndescribe('CommentsController', () => {\n  let controller: CommentsController;\n  let commentsService: CommentsService;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      controllers: [CommentsController],\n      providers: [\n        {\n          provide: CommentsService,\n          useValue: {\n            create: jest.fn(),\n            createNestedComment: jest.fn(),\n            delete: jest.fn(),\n            upvoteComment: jest.fn(),\n            downvoteComment: jest.fn(),\n            getCommentsByThreadId: jest.fn(),\n            getCommentById: jest.fn(),\n            getNestedComments: jest.fn(),\n          },\n        },\n      ],\n    }).compile();\n\n    controller = module.get<CommentsController>(CommentsController);\n    commentsService = module.get<CommentsService>(CommentsService);\n  });\n\n  it('should be defined', () => {\n    expect(controller).toBeDefined();\n  });\n});\n","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\comments\\comments.controller.ts",["276","277"],[],"import { BadRequestException, Body, Controller, Delete, Get, HttpException, HttpStatus, NotFoundException, Param, Patch, Post, Req, ValidationPipe } from '@nestjs/common';\nimport { ApiCreatedResponse, ApiNotFoundResponse, ApiOkResponse, ApiParam, ApiSecurity, ApiTags, ApiUnprocessableEntityResponse } from '@nestjs/swagger';\nimport { CommentsService } from './comments.service';\nimport { CreateCommentDto } from './dto/create-comment.dto';\nimport { Comment } from './schemas/comment.schema';\nimport { CreateNestedCommentDto } from './dto/create-nested-comment.dto';\n\n@ApiTags('comments')\n@Controller('comments')\nexport class CommentsController {\n    constructor(private readonly commentsService: CommentsService) {}\n\n    @Post()\n    @ApiSecurity('username')\n    @ApiCreatedResponse({ description: 'The comment has been successfully created.'})\n    @ApiUnprocessableEntityResponse({ description: 'Unable to create comment.'})\n    @ApiNotFoundResponse({ description: 'User or Thread not found'})\n    create(@Body(new ValidationPipe()) createCommentDto: CreateCommentDto): Promise<Comment> {\n        return this.commentsService\n            .create(createCommentDto)\n            .then(comment => comment)\n            .catch(error => {\n                if (error instanceof NotFoundException) {\n                    throw new HttpException('User or Thread not found', HttpStatus.NOT_FOUND);\n                }\n\n                throw new HttpException('Unable to create comment', HttpStatus.UNPROCESSABLE_ENTITY);\n            });\n    }\n\n    @Post(':id')\n    @ApiSecurity('username')\n    @ApiParam({ name: 'id', type: String, description: 'The id of the parent comment.' })\n    @ApiCreatedResponse({ description: 'The nested comment has been successfully created.'})\n    @ApiUnprocessableEntityResponse({ description: 'Unable to create nested comment.'})\n    @ApiNotFoundResponse({ description: 'User or Parent comment not found'})\n    createNestedComment(@Body(new ValidationPipe()) createNestedCommentDto: CreateNestedCommentDto, @Param('id') id: string): Promise<Comment> {\n        return this.commentsService\n            .createNestedComment(id, createNestedCommentDto)\n            .then(comment => comment)\n            .catch(error => {\n                if (error instanceof NotFoundException) {\n                    throw new HttpException('User or Parent comment not found', HttpStatus.NOT_FOUND);\n                }\n\n                throw new HttpException('Unable to create nested comment', HttpStatus.UNPROCESSABLE_ENTITY);\n            });\n    }\n\n    @Delete(':id')\n    @ApiSecurity('username')\n    @ApiParam({ name: 'id', type: String, description: 'The id of the comment to delete.' })\n    @ApiOkResponse({ description: 'The comment has been successfully deleted.'})\n    @ApiNotFoundResponse({ description: 'Comment not found'})\n    @ApiUnprocessableEntityResponse({ description: 'Unable to delete comment'})\n    delete(@Param('id') id: string, @Req() req: any): Promise<Comment> {\n        const username = req.headers['authorization'];\n\n        return this.commentsService\n            .delete(id, username)\n            .then(comment => comment)\n            .catch(error => {\n                if (error instanceof NotFoundException) {\n                    throw new HttpException('Comment not found', HttpStatus.NOT_FOUND);\n                }\n\n                throw new HttpException('Unable to delete comment', HttpStatus.UNPROCESSABLE_ENTITY);\n            });\n    }\n\n    @Patch(':id/upvote')\n    @ApiParam({ name: 'id', type: String, description: 'The id of the comment to upvote.' })\n    @ApiOkResponse({ description: 'The comment has been successfully upvoted.'})\n    @ApiNotFoundResponse({ description: 'Comment or User not found'})\n    @ApiUnprocessableEntityResponse({ description: 'Unable to upvote comment'})\n    upvote(@Param('id') id: string, @Body('username') username: string): Promise<Comment> {\n        return this.commentsService\n            .upvoteComment(id, username)\n            .then(comment => comment)\n            .catch(error => {\n                if (error instanceof NotFoundException) {\n                    throw new HttpException('Comment or User not found', HttpStatus.NOT_FOUND);\n                }\n\n                if (error instanceof BadRequestException) {\n                    throw new HttpException('Bad request', HttpStatus.BAD_REQUEST);\n                }\n\n                throw new HttpException('Unable to upvote comment', HttpStatus.UNPROCESSABLE_ENTITY);\n            });\n    }\n\n    @Patch(':id/downvote')\n    @ApiParam({ name: 'id', type: String, description: 'The id of the comment to downvote.' })\n    @ApiOkResponse({ description: 'The comment has been successfully downvoted.'})\n    @ApiNotFoundResponse({ description: 'Comment or User not found'})\n    @ApiUnprocessableEntityResponse({ description: 'Unable to downvote comment'})\n    downvote(@Param('id') id: string, @Body('username') username: string): Promise<Comment> {\n        return this.commentsService\n            .downvoteComment(id, username)\n            .then(comment => comment)\n            .catch(error => {\n                if (error instanceof NotFoundException) {\n                    throw new HttpException('Comment or User not found', HttpStatus.NOT_FOUND);\n                }\n\n                if (error instanceof BadRequestException) {\n                    throw new HttpException('Bad request', HttpStatus.BAD_REQUEST);\n                }\n\n                throw new HttpException('Unable to downvote comment', HttpStatus.UNPROCESSABLE_ENTITY);\n            });\n    }\n\n    @Get(':id/thread')\n    @ApiParam({ name: 'id', type: String, description: 'The id of the comment to get the thread from.' })\n    @ApiOkResponse({ description: 'The thread has been successfully retrieved.'})\n    @ApiNotFoundResponse({ description: 'Thread not found'})\n    @ApiUnprocessableEntityResponse({ description: 'Unable to get comments'})\n    getCommentsByThreadId(@Param('id') id: string): Promise<Comment[]> {\n        return this.commentsService\n            .getCommentsByThreadId(id)\n            .then(comments => comments)\n            .catch(error => {\n                if (error instanceof NotFoundException) {\n                    throw new HttpException('Thread not found', HttpStatus.NOT_FOUND);\n                }\n\n                throw new HttpException('Unable to get comments', HttpStatus.UNPROCESSABLE_ENTITY);\n            });\n    }\n\n    @Get()\n    @ApiSecurity('username')\n    @ApiOkResponse({ description: 'The comments have been successfully retrieved.'})\n    @ApiUnprocessableEntityResponse({ description: 'Unable to get comments'})\n    getComments(): Promise<Comment[]> {\n        return this.commentsService\n            .getComments()\n            .then(comments => comments)\n            .catch(error => {\n                throw new HttpException('Unable to get comments', HttpStatus.UNPROCESSABLE_ENTITY);\n            });\n    }\n\n    @Get(':id')\n    @ApiParam({ name: 'id', type: String, description: 'The id of the comment to get.' })\n    @ApiOkResponse({ description: 'The comment has been successfully retrieved.'})\n    @ApiNotFoundResponse({ description: 'Comment not found'})\n    @ApiUnprocessableEntityResponse({ description: 'Unable to get comment'})\n    getCommentById(@Param('id') id: string): Promise<Comment> {\n        return this.commentsService\n            .getCommentById(id)\n            .then(comment => comment)\n            .catch(error => {\n                if (error instanceof NotFoundException) {\n                    throw new HttpException('Comment not found', HttpStatus.NOT_FOUND);\n                }\n\n                throw new HttpException('Unable to get comment', HttpStatus.UNPROCESSABLE_ENTITY);\n            });\n    }\n\n    @Get(':id/nested')\n    @ApiParam({ name: 'id', type: String, description: 'The id of the comment to get nested comments from.' })\n    @ApiOkResponse({ description: 'The nested comments have been successfully retrieved.'})\n    @ApiNotFoundResponse({ description: 'Comment not found'})\n    @ApiUnprocessableEntityResponse({ description: 'Unable to get nested comments'})\n    getNestedComments(@Param('id') id: string): Promise<Comment[]> {\n        return this.commentsService\n            .getNestedComments(id)\n            .then(comments => comments)\n            .catch(error => {\n                if (error instanceof NotFoundException) {\n                    throw new HttpException('Comment not found', HttpStatus.NOT_FOUND);\n                }\n\n                throw new HttpException('Unable to get nested comments', HttpStatus.UNPROCESSABLE_ENTITY);\n            });\n    }\n}\n","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\comments\\comments.module.ts",[],[],"C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\comments\\comments.service.spec.ts",[],[],"C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\comments\\comments.service.ts",[],[],"C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\comments\\dto\\create-comment.dto.ts",[],[],"C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\comments\\dto\\create-nested-comment.dto.ts",[],[],"C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\comments\\schemas\\comment.schema.spec.ts",["278","279"],[],"import { getModelToken } from \"@nestjs/mongoose\";\nimport { TestingModule, Test } from \"@nestjs/testing\";\nimport { Model, Types } from \"mongoose\";\nimport { Comment, CommentDocument } from \"./comment.schema\";\n\ndescribe('Threads Model', () => { \n    let commentModel: Model<CommentDocument>;\n\n    beforeEach(async () => {\n        const module: TestingModule = await Test.createTestingModule({\n            providers: [\n                {\n                    provide: getModelToken(Comment.name),\n                    useValue: Model\n                }\n            ],\n        }).compile();\n\n        commentModel = module.get<Model<CommentDocument>>(getModelToken(Comment.name));\n    });\n\n    afterEach(() => {\n        jest.clearAllMocks();\n    });\n\n    describe(\"Happy Flow\", () => {\n        it(\"should create a comment\", async () => {\n            const commentData = {\n                username: \"testuser\",\n                content: \"This is a test comment.\"\n            };\n        \n            jest.spyOn(commentModel, 'create').mockResolvedValueOnce(commentData as any);\n        \n            const createdComment = await commentModel.create(commentData);\n        \n            expect(createdComment).toEqual(commentData);\n            expect(commentModel.create).toHaveBeenCalledWith(commentData);\n        });\n\n        it(\"should calculate the correct score for the comment\", () => {\n            const comment = new Comment();\n            comment.upvotes = [new Types.ObjectId(), new Types.ObjectId(), new Types.ObjectId()]; // Simulating upvotes\n            comment.downvotes = [new Types.ObjectId()]; // Simulating downvote\n        \n            const expectedScore = comment.upvotes.length - comment.downvotes.length;\n        \n            expect(comment.score).toEqual(expectedScore);\n        });\n    });\n\n    describe(\"Unhappy Flow\", () => {\n        it(\"should not create a comment with missing required fields\", async () => {\n            const incompleteCommentData = {\n                username: \"testuser\",\n                // Missing 'content' field\n            };\n        \n            jest.spyOn(commentModel, 'create').mockRejectedValueOnce(new Error('Content is required'));\n        \n            await expect(commentModel.create(incompleteCommentData)).rejects.toThrowError('Content is required');\n            expect(commentModel.create).toHaveBeenCalledWith(incompleteCommentData);\n        });\n\n        it(\"should handle malformed ObjectIDs when calculating comment score\", () => {\n            const comment = new Comment();\n            comment.upvotes = [\"invalidId1\", \"invalidId2\"] as any[]; // Invalid ObjectIDs\n            comment.downvotes = [new Types.ObjectId()]; // Valid ObjectID\n        \n            const calculatedScore = comment.score;\n        \n            expect(isNaN(calculatedScore)).toBe(true);\n        });\n    });\n});","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\comments\\schemas\\comment.schema.ts",[],[],"C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\friends\\dto\\create-friendship.dto.ts",[],[],"C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\friends\\dto\\delete-friendship.dto.ts",[],[],"C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\friends\\friends.controller.spec.ts",["280","281","282","283"],[],"import { Test, TestingModule } from '@nestjs/testing';\nimport { FriendsController } from './friends.controller';\nimport { FriendsService } from './friends.service';\nimport { getModelToken } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\n\nimport { User } from '../users/schemas/user.schema';\n\ndescribe('FriendsController', () => {\n  let controller: FriendsController;\n  let friendsService: FriendsService;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      controllers: [FriendsController],\n      providers: [\n        {\n          provide: FriendsService,\n          useValue: {\n            makeFriend: jest.fn(),\n            removeFriend: jest.fn()\n          }\n        }\n      ]\n    }).compile();\n\n    controller = module.get<FriendsController>(FriendsController);\n    friendsService = module.get<FriendsService>(FriendsService);\n  });\n\n  it('should be defined', () => {\n    expect(controller).toBeDefined();\n  });\n});\n","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\friends\\friends.controller.ts",["284","285"],[],"import { Body, Controller, Post, HttpException, HttpStatus, Delete, ValidationPipe, NotFoundException } from '@nestjs/common';\nimport { ApiCreatedResponse, ApiOkResponse, ApiTags, ApiUnprocessableEntityResponse } from '@nestjs/swagger';\n\nimport { FriendsService } from './friends.service';\nimport { CreateFriendshipDto } from './dto/create-friendship.dto';\nimport { DeleteFriendshipDto } from './dto/delete-friendship.dto';\n\n@ApiTags('friends')\n@Controller('friends')\nexport class FriendsController {\n    constructor(private readonly friendsService: FriendsService) {}\n\n    @Post()\n    @ApiCreatedResponse({ description: 'Friendship has been successfully created.'})\n    @ApiUnprocessableEntityResponse({ description: 'Unable to create friendship.'})\n    create(@Body(new ValidationPipe()) createFriendshipDto: CreateFriendshipDto): Promise<Record<string, any>> {\n        return this.friendsService\n            .makeFriend(createFriendshipDto.user, createFriendshipDto.friend)\n            .then(result => result)\n            .catch(error => {\n                if (error instanceof NotFoundException) {\n                    throw new HttpException(error.message, HttpStatus.NOT_FOUND);\n                }\n\n                throw new HttpException('Unable to create friendship', HttpStatus.UNPROCESSABLE_ENTITY);\n            });\n    };\n\n    @Delete()\n    @ApiOkResponse({ description: 'Friendship has been successfully deleted.'})\n    @ApiUnprocessableEntityResponse({ description: 'Unable to delete friendship.'})\n    remove(@Body(new ValidationPipe()) deleteFriendshipDTO: DeleteFriendshipDto): Promise<Record<string, any>> {\n        return this.friendsService\n            .removeFriend(deleteFriendshipDTO.user, deleteFriendshipDTO.friend)\n            .then(result => result)\n            .catch(error => {\n                if (error instanceof NotFoundException) {\n                    throw new HttpException(error.message, HttpStatus.NOT_FOUND);\n                }\n\n                throw new HttpException('Unable to delete friendship', HttpStatus.UNPROCESSABLE_ENTITY);\n            });\n    };\n}\n","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\friends\\friends.module.ts",[],[],"C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\friends\\friends.service.spec.ts",[],[],"C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\friends\\friends.service.ts",["286","287","288"],[],"import { Injectable, NotFoundException } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Neo4jService } from '../neo4j/neo4j.service';\nimport { Types } from 'mongoose';\n\n@Injectable()\nexport class FriendsService {\n    constructor(\n        @InjectModel('User') private readonly userModel,\n        private readonly neo4jService: Neo4jService\n    ) {}\n\n    private async userExists(username: string) {\n        const user = await this.userModel.findOne({ username });\n        return !!user;\n    }\n\n    /**\n     * Befriends two users\n     * @param user A username\n     * @param friend A username\n     */\n    async makeFriend(user: string, friend: string): Promise<Record<string, any>> {\n        const [userExists, friendExists] = await Promise.all([\n            this.userExists(user),\n            this.userExists(friend)\n        ]);\n\n        if (!userExists || !friendExists) {\n            throw new NotFoundException(`User ${!userExists ? user : friend} not found`);\n        }\n\n        const [mongoUser, mongoFried] = await Promise.all([\n            this.userModel.findOne({ username: user }),\n            this.userModel.findOne({ username: friend })\n        ]);\n\n        if (!mongoUser.isActive || !mongoFried.isActive) {\n            throw new NotFoundException(`User ${!mongoUser.isActive ? user : friend} is not active`);\n        }\n\n        const neo = this.neo4jService.beginTransaction();\n\n        try {\n            const existingFriendship = await neo.run(\n                `MATCH (u:User {username: $user})-[r:FRIENDS_WITH]-(f:User {username: $friend}) RETURN r`,\n                { user, friend }\n            );\n\n            if (existingFriendship.records.length > 0) {\n                return existingFriendship.records;\n            } else {\n                const result = await neo.run(\n                    `MERGE (u:User {username: $user})-[:FRIENDS_WITH]-(f:User {username: $friend})`,\n                    { user, friend }\n                );\n\n                await neo.commit();\n\n                return result.records;\n            }\n        } catch (error) {\n            await neo.rollback();\n            throw new Error('Could not make friend')\n        }\n    }\n\n    /**\n     * Unfriends two users\n     * @param user A username\n     * @param friend A username\n     */\n    async removeFriend(user: string, friend: string): Promise<Record<string, any>> {\n        const [userExists, friendExists] = await Promise.all([\n            this.userExists(user),\n            this.userExists(friend)\n        ]);\n\n        if (!userExists || !friendExists) {\n            throw new NotFoundException(`User ${!userExists ? user : friend} not found`);\n        }\n\n        const neo = this.neo4jService.beginTransaction();\n\n        try {\n            const existingFriendship = await neo.run(\n                `MATCH (u:User {username: $user})-[r:FRIENDS_WITH]-(f:User {username: $friend}) RETURN r`,\n                { user, friend }\n            );\n\n            if (existingFriendship.records.length > 0) {\n                const result = await neo.run(\n                    `MATCH (u:User {username: $user})-[r:FRIENDS_WITH]-(f:User {username: $friend}) DELETE r`,\n                    { user, friend }\n                );\n\n                await neo.commit();\n\n                return result.records;\n            } else {\n                return existingFriendship.records;\n            }\n        } catch (error) {\n            await neo.rollback();\n            throw new Error('Could not remove friend')\n        }\n    }\n}\n","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\middleware\\is-active.middleware.spec.ts",[],[],"C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\middleware\\is-active.middleware.ts",["289","290"],[],"import { Injectable, NestMiddleware } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\nimport { User } from '../users/schemas/user.schema';\n\n@Injectable()\nexport class IsActiveMiddleware implements NestMiddleware {\n  constructor(\n    @InjectModel(User.name) private userModel: Model<User>\n  ) {}\n\n  async use(req: any, res: any, next: () => void) {\n    try {\n      const username = req.headers['authorization'];\n\n      if (!username) {\n        return res\n          .status(401)\n          .send({ message: 'No authorization header provided' });\n      }\n\n      const user = await this.userModel.findOne({ username: username });\n\n      if (!user) {\n        return res\n          .status(404)\n          .send({ message: 'Authenticated user not found' });\n      }\n\n      if (!user.isActive) {\n        return res\n          .status(401)\n          .send({ message: 'Authenticated user is not active' });\n      }\n\n      next();\n    } catch (error) {\n      return res\n        .status(500)\n        .send({ message: 'Internal server error' });\n    }\n  }\n}\n","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\middleware\\middleware.module.ts",["291","292","293"],[],"import { MiddlewareConsumer, Module, NestModule } from '@nestjs/common';\nimport { IsActiveMiddleware } from './is-active.middleware';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { UserSchema } from '../users/schemas/user.schema';\n\n@Module({\n    imports: [\n        MongooseModule.forFeature([{ name: 'User', schema: UserSchema }]),\n    ]\n})\nexport class MiddlewareModule implements NestModule {\n    static forRoot(options?: any) {\n        return {\n            module: MiddlewareModule,\n            providers: [\n                {\n                    provide: 'MIDDLEWARE_OPTIONS',\n                    useValue: options || {}\n                }\n            ]\n        }\n    } \n    \n    configure(consumer: MiddlewareConsumer) {\n        const options = this.getOptions();\n\n        consumer\n            .apply(IsActiveMiddleware)\n            .exclude(...options.exclude)\n            .forRoutes(options)\n    }\n\n    getOptions(): any {\n        const defaultOptions = {\n            exclude: [],\n            forRoutes: []\n        }\n\n        const options = this.getMiddlewareOptions();\n        return { ...defaultOptions, ...options };\n    }\n\n    getMiddlewareOptions(): any {\n        const middlewareOptions = Reflect.getMetadata('MIDDLEWARE_OPTIONS', MiddlewareModule);\n\n        return middlewareOptions ? middlewareOptions : {};\n    }\n}\n","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\neo4j\\neo4j-config.interface.ts",[],[],"C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\neo4j\\neo4j-transaction.interceptor.ts",["294"],[],"import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from \"@nestjs/common\";\nimport { Neo4jService } from \"./neo4j.service\";\nimport { Observable } from \"rxjs\";\nimport { Transaction } from \"neo4j-driver\";\nimport { tap, catchError } from \"rxjs/operators\";\n\n@Injectable()\nexport class Neo4jTransactionInterceptor implements NestInterceptor {\n\n    constructor(private readonly neo4jService: Neo4jService) {}\n\n    intercept(context: ExecutionContext, next: CallHandler): Observable<any> {\n        const transaction: Transaction = this.neo4jService.beginTransaction()\n\n        context.switchToHttp().getRequest().transaction = transaction\n\n        return next.handle()\n            .pipe(\n                tap(() => {\n                    transaction.commit()\n                }),\n                catchError(e => {\n                    transaction.rollback()\n                    throw e\n                })\n            )\n    }\n}","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\neo4j\\neo4j.module.ts",["295"],[],"import { DynamicModule, Module, Provider } from '@nestjs/common';\nimport { Neo4jService } from './neo4j.service';\nimport { ConfigModule } from '@nestjs/config';\nimport { createDriver } from './neo4j.utils';\nimport { Neo4jConfig } from './neo4j-config.interface';\nimport { Neo4jTransactionInterceptor } from './neo4j-transaction.interceptor';\nimport { config } from 'rxjs';\n\nconst NEO4J_OPTIONS = 'NEO4J_OPTIONS';\nconst NEO4J_DRIVER = 'NEO4J_DRIVER';\n\n@Module({\n  imports: [ ConfigModule ],\n  providers: [\n    {\n      provide: 'NEO4J_CONFIG',\n      useValue: config\n    }\n  ]\n})\nexport class Neo4jModule {\n\n  static forRoot(config: object): DynamicModule {\n    return {\n      module: Neo4jModule,\n      global: true,\n      providers: [\n        {\n          provide: NEO4J_OPTIONS,\n          useValue: config\n        },\n        {\n          provide: NEO4J_DRIVER,\n          inject: [NEO4J_OPTIONS],\n          useFactory: async (config: Neo4jConfig) => {\n            return await createDriver(config);\n          }\n        },\n        Neo4jService\n      ],\n      exports: [ Neo4jService, Neo4jTransactionInterceptor ]\n    }\n  }\n\n  static forRootAsync(configProvider): DynamicModule {\n    return {\n      module: Neo4jModule,\n      global: true,\n      imports: [ ConfigModule ],\n      providers: [\n        {\n          provide: NEO4J_OPTIONS,\n          ...configProvider\n        } as Provider<any>,\n        {\n          provide: NEO4J_DRIVER,\n          inject: [ NEO4J_OPTIONS ],\n          useFactory: async (config: Neo4jConfig) => {\n            return await createDriver(config);\n          }\n        },\n        Neo4jService\n      ],\n      exports: [ Neo4jService ]\n    }\n  }\n\n}\n","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\neo4j\\neo4j.service.spec.ts",["296","297","298"],[],"import { Test, TestingModule } from '@nestjs/testing';\nimport { Neo4jService } from './neo4j.service';\n\ndescribe('Neo4jService', () => {\n  // let service: Neo4jService;\n\n  // beforeEach(async () => {\n  //   const module: TestingModule = await Test.createTestingModule({\n  //     providers: [Neo4jService],\n  //   }).compile();\n\n  //   service = module.get<Neo4jService>(Neo4jService);\n  // });\n\n  it('should be defined', () => {\n    // expect(service).toBeDefined();\n    expect(true).toBe(true);\n  });\n});\n","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\neo4j\\neo4j.service.ts",["299","300"],[],"import { Inject, Injectable } from '@nestjs/common';\nimport { Result, Session, Transaction, session } from 'neo4j-driver';\nimport { TransactionImpl } from 'neo4j-driver/lib';\n\n@Injectable()\nexport class Neo4jService {\n    constructor(\n        @Inject(\"NEO4J_CONFIG\") private readonly config,\n        @Inject(\"NEO4J_DRIVER\") private readonly driver\n    ) {}\n\n    getDriver() {\n        return this.driver;\n    }\n\n    beginTransaction(database?: string): Transaction {\n        const session = this.getWriteSession(database);\n\n        return session.beginTransaction();\n    }\n\n    getReadSession(database?: string): Session {\n        return this.driver.session({\n            database: database || this.config.database,\n            defaultAccessMode: session.READ\n        })\n    }\n\n    getWriteSession(database?: string): Session {\n        return this.driver.session({\n            database: database || this.config.database,\n            defaultAccessMode: session.WRITE\n        })\n    }\n\n    read(cypher: string, params?: Record<string, any>, databaseOrTranscation?: string | Transaction): Result {\n        if (databaseOrTranscation instanceof TransactionImpl) {\n            return (<Transaction> databaseOrTranscation).run(cypher, params);\n        }\n\n        const session = this.getReadSession(<string> databaseOrTranscation);\n        return session.run(cypher, params);\n    }\n\n    write(cypher: string, params?: Record<string, any>, databaseOrTranscation?: string | Transaction): Result {\n        if (databaseOrTranscation instanceof TransactionImpl) {\n            return (<Transaction> databaseOrTranscation).run(cypher, params);\n        }\n\n        const session = this.getWriteSession(<string> databaseOrTranscation);\n        return session.run(cypher, params);\n    }\n\n    opApplicationShutdown() {\n        this.driver.close();\n    }\n}\n","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\neo4j\\neo4j.utils.ts",[],[],"C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\threads\\dto\\create-thread.dto.ts",[],[],"C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\threads\\dto\\update-thread.dto.ts",[],[],"C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\threads\\schemas\\threads.schema.spec.ts",["301","302","303","304","305","306","307"],[],"import { getModelToken } from \"@nestjs/mongoose\";\nimport { TestingModule, Test } from \"@nestjs/testing\";\nimport { Model, Types } from \"mongoose\";\nimport { Thread, ThreadDocument } from \"./threads.schema\";\n\ndescribe('Threads Model', () => { \n    let threadModel: Model<ThreadDocument>;\n\n    beforeEach(async () => {\n        const module: TestingModule = await Test.createTestingModule({\n            providers: [\n                {\n                    provide: getModelToken(Thread.name),\n                    useValue: Model\n                }\n            ],\n        }).compile();\n\n        threadModel = module.get<Model<ThreadDocument>>(getModelToken(Thread.name));\n    });\n\n    afterEach(() => {\n        jest.clearAllMocks();\n    });\n\n    describe(\"Happy Flow\", () => {\n        it(\"should create a thread\", async () => {\n            const threadData = {\n                username: \"testuser\",\n                title: \"Test Thread\",\n                content: \"This is a test thread content.\"\n            };\n        \n            jest.spyOn(threadModel, 'create').mockResolvedValueOnce(threadData as any);\n        \n            const createdThread = await threadModel.create(threadData);\n        \n            expect(createdThread).toEqual(threadData);\n            expect(threadModel.create).toHaveBeenCalledWith(threadData);\n        });\n\n        it(\"should calculate the correct score for the thread\", () => {\n            const thread = new Thread();\n            thread.upvotes = [new Types.ObjectId(), new Types.ObjectId(), new Types.ObjectId()]; // Simulating upvotes\n            thread.downvotes = [new Types.ObjectId()]; // Simulating downvote\n        \n            const expectedScore = thread.upvotes.length - thread.downvotes.length;\n        \n            expect(thread.score).toEqual(expectedScore);\n        });\n        \n        it(\"should update a thread's title\", async () => {\n            const initialThreadData = {\n                username: \"testuser\",\n                title: \"Initial Thread Title\",\n                content: \"This is the initial content.\"\n            };\n        \n            const updatedThreadData = {\n                username: \"testuser\",\n                title: \"Updated Thread Title\",\n                content: \"This is the updated content.\"\n            };\n\n            jest.spyOn(threadModel, 'create').mockResolvedValueOnce(initialThreadData as any);\n        \n            const thread = await threadModel.create(initialThreadData);\n            jest.spyOn(threadModel, 'findByIdAndUpdate').mockResolvedValueOnce(updatedThreadData as any);\n        \n            const updatedThread = await threadModel.findByIdAndUpdate(thread._id, { title: \"Updated Thread Title\" }, { new: true });\n        \n            expect(updatedThread).toEqual(updatedThreadData);\n            expect(threadModel.findByIdAndUpdate).toHaveBeenCalledWith(thread._id, { title: \"Updated Thread Title\" }, { new: true });\n        });\n\n        it(\"should have timestamps when creating and updating a thread\", async () => {\n            const threadData = {\n                username: \"testuser\",\n                title: \"Test Thread\",\n                content: \"This is a test thread content.\"\n            };\n        \n            jest.spyOn(threadModel, 'create').mockResolvedValueOnce({\n                ...threadData,\n                createdAt: new Date(-1000),\n                updatedAt: new Date(+1000) // Simulating an update\n            } as any);\n\n            const createdThread = await threadModel.create(threadData);\n        \n            expect(createdThread.createdAt).toBeInstanceOf(Date);\n            expect(createdThread.updatedAt).toBeInstanceOf(Date);\n            expect(createdThread.createdAt).toEqual(createdThread.createdAt);\n        \n            // Simulate an update\n            jest.spyOn(threadModel, 'findByIdAndUpdate').mockResolvedValueOnce({ ...createdThread, updatedAt: new Date() } as any);\n            const updatedThread = await threadModel.findByIdAndUpdate(createdThread._id, { content: \"Updated content\" }, { new: true });\n        \n            expect(updatedThread.createdAt).toEqual(createdThread.createdAt);\n            expect(updatedThread.updatedAt.valueOf()).toBeGreaterThan(createdThread.updatedAt.valueOf());\n        });\n\n        it(\"should calculate a negative score for the thread\", () => {\n            const thread = new Thread();\n            thread.upvotes = [new Types.ObjectId()];\n            thread.downvotes = [new Types.ObjectId(), new Types.ObjectId(), new Types.ObjectId()]; // Simulating more downvotes than upvotes\n        \n            const calculatedScore = thread.score;\n        \n            expect(calculatedScore).toBeLessThanOrEqual(0);\n        });\n    });\n\n    describe(\"Unhappy Flow\", () => {\n        it(\"should not create a thread with missing required fields\", async () => {\n            const incompleteThreadData = {\n                username: \"testuser\",\n                title: \"Test Thread\"\n                // Missing 'content' field\n            };\n        \n            jest.spyOn(threadModel, 'create').mockRejectedValueOnce(new Error('Content is required'));\n        \n            await expect(threadModel.create(incompleteThreadData)).rejects.toThrow('Content is required');\n            expect(threadModel.create).toHaveBeenCalledWith(incompleteThreadData);\n        });\n\n        it(\"should handle malformed score calculation\", () => {\n            const thread = new Thread();\n            thread.upvotes = [\"invalidId\", \"anotherInvalidId\"] as any[]; // Invalid ObjectIDs\n            thread.downvotes = [\"yetAnotherInvalidId\"] as any[]; // Invalid ObjectID\n        \n            const calculatedScore = thread.score;\n\n            expect(calculatedScore).toBeNaN();\n        });\n        \n    });\n});","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\threads\\schemas\\threads.schema.ts",["308"],[],"import { Prop, Schema, SchemaFactory } from \"@nestjs/mongoose\";\nimport { HydratedDocument, Document, Types } from \"mongoose\";\n\nexport type ThreadDocument = HydratedDocument<Thread>;\n\n@Schema({ timestamps: true })\nexport class Thread {\n    _id?: Types.ObjectId;\n\n    @Prop({ required: true, index: true }) // Index for username\n    username: string;\n\n    @Prop({ required: true })\n    title: string;\n\n    @Prop({ required: true })\n    content: string;\n\n    // Consideration: Referencing related data (User and Comment) for scalability\n    @Prop({ type: [{ type: Types.ObjectId, ref: 'Comment' }], default: [] })\n    comments: Types.ObjectId[];\n\n    @Prop({ type: [{ type: Types.ObjectId, ref: 'User' }], default: [] })\n    upvotes: Types.ObjectId[];\n\n    @Prop({ type: [{ type: Types.ObjectId, ref: 'User' }], default: [] })\n    downvotes: Types.ObjectId[];\n\n    // Index for timestamps if common queries involve time-based filtering/sorting\n    @Prop({ index: true })\n    createdAt: Date;\n\n    @Prop({ index: true })\n    updatedAt: Date;\n\n    // Calculated field for score\n    get score(): number {\n        if (\n            this.upvotes.some(upvote => !Types.ObjectId.isValid(upvote)) || \n            this.downvotes.some(downvote => !Types.ObjectId.isValid(downvote))\n        ) return NaN;\n\n        return this.upvotes.length - this.downvotes.length;\n    }\n}\n\nexport const ThreadSchema = SchemaFactory.createForClass(Thread);","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\threads\\threads.controller.spec.ts",["309","310","311","312","313","314"],[],"import { Test, TestingModule } from '@nestjs/testing';\nimport { ThreadsController } from './threads.controller';\nimport { ThreadsService } from './threads.service';\nimport { getModelToken } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\n\nimport { User } from '../users/schemas/user.schema';\nimport { Thread } from './schemas/threads.schema';\nimport { Comment } from '../comments/schemas/comment.schema';\n\ndescribe('ThreadsController', () => {\n  let controller: ThreadsController;\n  let threadsService: ThreadsService;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      controllers: [ThreadsController],\n      providers: [\n        {\n          provide: ThreadsService,\n          useValue: {\n            create: jest.fn(),\n            update: jest.fn(),\n            upvote: jest.fn(),\n            downvote: jest.fn(),\n            delete: jest.fn(),\n            findAllSortedByUpvotes: jest.fn(),\n            findAllSortedByScore: jest.fn(),\n            findAllSortedByComments: jest.fn(),\n            findAll: jest.fn(),\n            findOne: jest.fn(),\n          },\n        },\n      ],\n    }).compile();\n\n    controller = module.get<ThreadsController>(ThreadsController);\n    threadsService = module.get<ThreadsService>(ThreadsService);\n  });\n\n  it('should be defined', () => {\n    expect(controller).toBeDefined();\n  });\n});\n","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\threads\\threads.controller.ts",["315","316","317"],[],"import { BadRequestException, Body, Controller, Delete, Get, HttpException, HttpStatus, NotFoundException, Param, Patch, Post, Put, Query, Req, ValidationPipe } from '@nestjs/common';\nimport { ApiCreatedResponse, ApiNotFoundResponse, ApiOkResponse, ApiParam, ApiQuery, ApiSecurity, ApiTags, ApiUnprocessableEntityResponse } from '@nestjs/swagger';\nimport { ThreadsService } from './threads.service';\nimport { CreateThreadDto } from './dto/create-thread.dto';\nimport { Thread } from './schemas/threads.schema';\n\n@ApiTags('threads')\n@Controller('threads')\nexport class ThreadsController {\n    constructor(private readonly threadsService: ThreadsService) {}\n\n    @Post()\n    @ApiSecurity('username')\n    @ApiCreatedResponse({ description: 'The thread has been successfully created.'})\n    @ApiUnprocessableEntityResponse({ description: 'Unable to create thread.'})\n    @ApiNotFoundResponse({ description: 'User not found'})\n    create(@Body(new ValidationPipe()) createThreadDto: CreateThreadDto): Promise<Thread> {\n        return this.threadsService\n            .create(createThreadDto)\n            .then(thread => thread)\n            .catch(error => {\n                if (error instanceof NotFoundException) {\n                    throw new HttpException('User not found', HttpStatus.NOT_FOUND);\n                }\n\n                throw new HttpException('Unable to create thread', HttpStatus.UNPROCESSABLE_ENTITY);\n            });\n    };\n\n    @Put(':id')\n    @ApiSecurity('username')\n    @ApiParam({ name: 'id', type: String, description: 'The id of the thread to update.' })\n    @ApiOkResponse({ description: 'The thread has been successfully updated.'})\n    @ApiNotFoundResponse({ description: 'Thread not found'})\n    @ApiUnprocessableEntityResponse({ description: 'Unable to update thread'})\n    update(@Body(new ValidationPipe()) createThreadDto: CreateThreadDto, @Param('id') id: string): Promise<Thread> {\n        return this.threadsService\n            .update(id, createThreadDto)\n            .then(thread => thread)\n            .catch(error => {\n                if (error instanceof NotFoundException) {\n                    throw new HttpException('Thread not found', HttpStatus.NOT_FOUND);\n                }\n\n                throw new HttpException('Unable to update thread', HttpStatus.UNPROCESSABLE_ENTITY);\n            });\n    };\n\n    @Patch(':id/upvote')\n    @ApiSecurity('username')\n    @ApiParam({ name: 'id', type: String, description: 'The id of the thread to upvote.' })\n    @ApiOkResponse({ description: 'The thread has been successfully upvoted.'})\n    @ApiNotFoundResponse({ description: 'Thread not found'})\n    @ApiNotFoundResponse({ description: 'User not found'})\n    @ApiUnprocessableEntityResponse({ description: 'Unable to upvote thread'})\n    upvote(@Param('id') id: string, @Req() req: any): Promise<Thread> {\n        const username = req.headers['authorization'];\n\n        return this.threadsService\n            .upvote(id, username)\n            .then(thread => thread)\n            .catch(error => {\n                if (error instanceof NotFoundException) {\n                    throw new HttpException('Thread or User not found', HttpStatus.NOT_FOUND);\n                }\n\n                if (error instanceof BadRequestException) {\n                    throw new HttpException('Already upvoted this thread', HttpStatus.BAD_REQUEST);\n                }\n\n                throw new HttpException('Unable to upvote thread', HttpStatus.UNPROCESSABLE_ENTITY);\n            });\n    };\n\n    @Patch(':id/downvote')\n    @ApiSecurity('username')\n    @ApiParam({ name: 'id', type: String, description: 'The id of the thread to downvote.' })\n    @ApiOkResponse({ description: 'The thread has been successfully downvoted.'})\n    @ApiNotFoundResponse({ description: 'Thread not found'})\n    @ApiNotFoundResponse({ description: 'User not found'})\n    @ApiUnprocessableEntityResponse({ description: 'Unable to downvote thread'})\n    downvote(@Param('id') id: string, @Req() req: any): Promise<Thread> {\n        const username = req.headers['authorization'];\n        \n        return this.threadsService\n            .downvote(id, username)\n            .then(thread => thread)\n            .catch(error => {\n                if (error instanceof NotFoundException) {\n                    throw new HttpException('Thread or User not found', HttpStatus.NOT_FOUND);\n                }\n\n                if (error instanceof BadRequestException) {\n                    throw new HttpException('Bad request', HttpStatus.BAD_REQUEST);\n                }\n\n                throw new HttpException('Unable to downvote thread', HttpStatus.UNPROCESSABLE_ENTITY);\n            });\n    };\n\n    @Delete(':id')\n    @ApiSecurity('username')\n    @ApiParam({ name: 'id', type: String, description: 'The id of the thread to delete.' })\n    @ApiOkResponse({ description: 'The thread has been successfully deleted.'})\n    @ApiNotFoundResponse({ description: 'Thread not found'})\n    @ApiUnprocessableEntityResponse({ description: 'Unable to delete thread'})\n    delete(@Param('id') id: string, @Req() req: any): Promise<Thread> {\n        const username = req.headers['authorization'];\n        \n        return this.threadsService\n            .delete(id, username)\n            .then(thread => thread)\n            .catch(error => {\n                if (error instanceof NotFoundException) {\n                    throw new HttpException('Thread not found', HttpStatus.NOT_FOUND);\n                }\n\n                throw new HttpException('Unable to delete thread', HttpStatus.UNPROCESSABLE_ENTITY);\n            });\n    };\n\n    @Get()\n    @ApiSecurity('username')\n    @ApiQuery({ name: 'sort', type: String, description: 'The sorting method: upvotes, score, comments.', required: false })\n    @ApiOkResponse({ description: 'The threads have been successfully retrieved.'})\n    findAll(@Query('sort') sort: string): Promise<Thread[]> {\n        const sortMethods = {\n            upvotes: () => this.threadsService.findAllSortedByUpvotes(),\n            score: () => this.threadsService.findAllSortedByScore(),\n            comments: () => this.threadsService.findAllSortedByComments(),\n            undefined: () => this.threadsService.findAll()\n        };\n\n        const sortMethod = sortMethods[sort];\n\n        if (!sortMethod) {\n            throw new BadRequestException('Invalid sorting method');\n        }\n\n        try {\n            return sortMethod();\n        } catch (error) {\n            throw new HttpException('Unable to retrieve threads', HttpStatus.UNPROCESSABLE_ENTITY);\n        }\n    }\n\n    @Get(':id')\n    @ApiSecurity('username')\n    @ApiParam({ name: 'id', type: String, description: 'The id of the thread to retrieve.' })\n    @ApiOkResponse({ description: 'The thread has been successfully retrieved.'})\n    @ApiNotFoundResponse({ description: 'Thread not found'})\n    findOne(@Param('id') id: string): Promise<Thread> {\n        return this.threadsService\n            .findOne(id)\n            .then(thread => thread)\n            .catch(error => {\n                if (error instanceof NotFoundException) {\n                    throw new HttpException('Thread not found', HttpStatus.NOT_FOUND);\n                }\n\n                throw new HttpException('Unable to retrieve thread', HttpStatus.UNPROCESSABLE_ENTITY);\n            });\n    }\n}\n","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\threads\\threads.module.ts",[],[],"C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\threads\\threads.service.spec.ts",[],[],"C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\threads\\threads.service.ts",["318","319"],[],"import { BadRequestException, Inject, Injectable, NotFoundException, UnauthorizedException } from '@nestjs/common';\nimport { Thread } from './schemas/threads.schema';\nimport { User } from '../users/schemas/user.schema';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model, Types } from 'mongoose';\nimport { CreateThreadDto } from './dto/create-thread.dto';\nimport { NotFoundError } from 'rxjs';\nimport { Neo4jService } from '../neo4j/neo4j.service';\nimport { UpdateThreadDto } from './dto/update-thread.dto';\n\n@Injectable()\nexport class ThreadsService {\n    constructor (\n        @InjectModel(Thread.name) private threadModel: Model<Thread>,\n        @InjectModel(User.name) private userModel: Model<User>,\n        private readonly neo4jService: Neo4jService\n    ) {}\n\n    async create(createThreadDto: CreateThreadDto): Promise<Thread> {\n        const neo = this.neo4jService.beginTransaction();\n\n        const session = await this.threadModel.db.startSession();\n        session.startTransaction();\n\n        try {\n            const createdThread = await this.threadModel.create([createThreadDto], { session });\n\n            await neo.run(\n                `CREATE (t:Thread { title: $title, content: $content, username: $username }) RETURN t`,\n                { title: createThreadDto.title, content: createThreadDto.content, username: createThreadDto.username }\n            );\n\n            await neo.commit();\n            await session.commitTransaction();\n\n            return createdThread[0];\n        } catch (error) {\n            await neo.rollback();\n            await session.abortTransaction();\n            throw error;\n        } finally {\n            session.endSession();\n        }\n    }\n\n    async update(id: string, updateThreadDto: UpdateThreadDto): Promise<Thread> {\n        const session = await this.threadModel.db.startSession();\n        session.startTransaction();\n\n        try {\n            const thread = await this.threadModel.findOne({ _id: id }).session(session);\n\n            if (!thread) {\n                throw new NotFoundException('Thread not found');\n            }\n\n            if (thread.username !== updateThreadDto.username) {\n                throw new UnauthorizedException('User is not authorized to update this thread');\n            }\n\n            const updatedThread = await this.threadModel.findOneAndUpdate({ _id: id }, updateThreadDto, { new: true, session });\n\n            await session.commitTransaction();\n\n            return updatedThread;\n        } catch (error) {\n            await session.abortTransaction();\n            throw error;\n        } finally {\n            session.endSession();\n        }\n    }\n\n    async upvote(id: string, username: string): Promise<Thread> {\n        const neo = this.neo4jService.beginTransaction();\n        const session = await this.threadModel.db.startSession();\n        session.startTransaction();\n\n        try {\n            const thread = await this.threadModel.findOne({ _id: id }).session(session);\n\n            if (!thread) {\n                throw new NotFoundException('Thread not found');\n            }\n\n            const user: User = await this.userModel.findOne({ username: username }).session(session);\n\n            if (!user) {\n                throw new NotFoundException('User not found');\n            }\n\n            const hasUpvoted = thread.upvotes.includes(user._id);\n            const hasDownvoted = thread.downvotes.includes(user._id);\n\n            if (hasUpvoted) {\n                throw new BadRequestException('User has already upvoted this thread');\n            }\n\n            if (hasDownvoted) {\n                const idx = thread.downvotes.indexOf(user._id);\n                thread.downvotes.splice(idx, 1);\n            }\n\n            thread.upvotes.push(user._id);\n            await thread.save({ session });\n\n            await neo.run(\n                `MATCH (u:User { username: $username }), (t:Thread { id: $id }) MERGE (u)-[:UPVOTED]->(t)`,\n                { username: username, id: thread._id }\n            );\n\n            await neo.commit();\n            await session.commitTransaction();\n\n            return thread;\n        } catch (error) {\n            await neo.rollback();\n            await session.abortTransaction();\n            throw error;\n        } finally {\n            session.endSession();\n        }\n    }\n\n    async downvote(id: string, username: string): Promise<Thread> {\n        const neo = this.neo4jService.beginTransaction();\n        const session = await this.threadModel.db.startSession();\n        session.startTransaction();\n\n        try {\n            const thread = await this.threadModel.findOne({ _id: id }).session(session);\n\n            if (!thread) {\n                throw new NotFoundException('Thread not found');\n            }\n\n            const user: User = await this.userModel.findOne({ username: username }).session(session);\n\n            if (!user) {\n                throw new NotFoundException('User not found');\n            }\n\n            const hasUpvoted = thread.upvotes.includes(user._id);\n            const hasDownvoted = thread.downvotes.includes(user._id);\n\n            if (hasDownvoted) {\n                throw new BadRequestException('User has already downvoted this thread');\n            }\n\n            if (hasUpvoted) {\n                const idx = thread.upvotes.indexOf(user._id);\n                thread.upvotes.splice(idx, 1);\n            }\n\n            thread.downvotes.push(user._id);\n            await thread.save({ session });\n\n            await neo.run(\n                `MATCH (u:User { username: $username }), (t:Thread { id: $id }) MERGE (u)-[:DOWNVOTED]->(t)`,\n                { username: username, id: thread._id }\n            );\n\n            await neo.commit();\n            await session.commitTransaction();\n\n            return thread;\n        } catch (error) {\n            await neo.rollback();\n            await session.abortTransaction();\n            throw error;\n        } finally {\n            session.endSession();\n        }\n    }\n\n    async delete(id: string, username: string): Promise<Thread> {\n        const neo = this.neo4jService.beginTransaction();\n        const session = await this.threadModel.db.startSession();\n        session.startTransaction();\n\n        try {\n            const thread = await this.threadModel.findOne({ _id: id }).session(session);\n\n            if (!thread) {\n                throw new NotFoundException('Thread not found');\n            }\n\n            if (thread.username !== username) {\n                throw new UnauthorizedException('User is not authorized to delete this thread');\n            }\n\n            const deletedThread = await this.threadModel.findOneAndDelete({ _id: id }, { session });\n\n            await Promise.all([\n                neo.run(`MATCH (:User)-[r:UPVOTED]->(t:Thread { id: $id }) DELETE r`, { id: thread._id } ),\n                neo.run(`MATCH (:User)-[r:DOWNVOTED]->(t:Thread { id: $id }) DELETE r`, { id: thread._id } ),\n                neo.run(`MATCH (t:Thread { id: $id }) DETACH DELETE t`, { id: thread._id } )\n            ]);\n\n            await neo.commit();\n            await session.commitTransaction();\n\n            return deletedThread;\n        } catch (error) {\n            await neo.rollback();\n            await session.abortTransaction();\n            throw error;\n        } finally {\n            session.endSession();\n        }\n    }\n\n    async findAll(): Promise<Thread[]> {\n        try {\n            return this.threadModel\n                .find()\n                .select('-comments');\n        } catch (error) {\n            throw new NotFoundException('Threads not found');\n        }\n    }\n\n    async findAllSortedByUpvotes(): Promise<Thread[]> {\n        try {\n            return this.threadModel\n                .find()\n                .sort({ upvotes: -1 })\n                .select('-comments');\n        } catch (error) {\n            throw new NotFoundException('Threads not found');\n        }\n    }\n\n    async findAllSortedByScore(): Promise<Thread[]> {\n        try {\n            return this.threadModel.aggregate([\n                { $addFields: { voteDifference: { $subtract: [ { $size: \"$upvotes\" }, { $size: \"$downvotes\" } ] } } },\n                { $sort: { voteDifference: -1 } },\n                { $project: { comments: 0 } }\n            ]);\n        } catch (error) {\n            throw new NotFoundException('Threads not found');\n        }\n    }\n\n    async findAllSortedByComments(): Promise<Thread[]> {\n        try {\n            return this.threadModel.aggregate([\n                { $addFields: { commentCount: { $size: \"$comments\" } } },\n                { $sort: { commentCount: -1 } },\n                { $project: { comments: 0 } }\n            ]);\n        } catch (error) {\n            throw new NotFoundException('Threads not found');\n        }\n    }\n\n    async findOne(id: string): Promise<Thread> {\n        try {\n            const thread = await this.threadModel.aggregate([\n                { $match: { _id: new Types.ObjectId(id) } },\n                {\n                    $lookup: {\n                        from: 'comments', // Changed from 'comments' to 'comment'\n                        localField: '_id',\n                        foreignField: 'thread',\n                        as: 'comments'\n                    }\n                },\n                {\n                    $addFields: {\n                        upvotesCount: { $size: \"$upvotes\" },\n                        downvotesCount: { $size: \"$downvotes\" },\n                        comments: {\n                            $map: {\n                                input: \"$comments\",\n                                as: \"comment\",\n                                in: {\n                                    _id: \"$$comment._id\",\n                                    content: \"$$comment.content\",\n                                    upvotesCount: { $size: \"$$comment.upvotes\" },\n                                    downvotesCount: { $size: \"$$comment.downvotes\" },\n                                }\n                            }\n                        }\n                    }\n                },\n                { $unset: [\"upvotes\", \"downvotes\"] }\n            ]);\n\n            if (!thread.length) {\n                throw new NotFoundException('Thread not found');\n            }\n\n            return thread[0];\n        } catch (error) {\n            throw new Error('Unable to find thread');\n        }\n    }\n}\n","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\users\\dto\\create-user.dto.ts",[],[],"C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\users\\dto\\delete-user.dto.ts",[],[],"C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\users\\dto\\update-user.dto.ts",[],[],"C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\users\\schemas\\user.schema.spec.ts",["320","321","322","323","324"],[],"import { Test, TestingModule } from '@nestjs/testing';\nimport { getModelToken } from '@nestjs/mongoose';\nimport { User, UserDocument, UserSchema } from './user.schema';\nimport { Model } from 'mongoose';\n\ndescribe('User Model', () => { \n    let userModel: Model<UserDocument>;\n\n    beforeEach(async () => {\n        const module: TestingModule = await Test.createTestingModule({\n            providers: [\n                {\n                    provide: getModelToken(User.name),\n                    useValue: Model\n                }\n            ],\n        }).compile();\n\n        userModel = module.get<Model<UserDocument>>(getModelToken(User.name));\n    });\n\n    afterEach(() => {\n        jest.clearAllMocks();\n    });\n\n    describe(\"Happy Flow\", () => {\n        it(\"should create a user\", async () => {\n            const userData: User = {\n                username: \"testuser\",\n                password: \"testpassword\",\n                isActive: true\n            };\n\n            jest.spyOn(userModel, 'create').mockResolvedValueOnce(userData as any);\n\n            const createdUser = await userModel.create(userData);\n\n            expect(createdUser).toEqual(userData);\n            expect(userModel.create).toHaveBeenCalledWith(userData);\n        });\n\n        it(\"should create a user with default isActive status\", async () => {\n            const userData: User = {\n                username: \"testuser\",\n                password: \"testpassword\"\n            };\n\n            jest.spyOn(userModel, 'create').mockResolvedValueOnce(userData as any);\n\n            const createdUser = await userModel.create(userData);\n\n            expect(createdUser).toEqual(userData);\n            expect(userModel.create).toHaveBeenCalledWith(userData);\n        });\n\n        it(\"should update user isActive status\", async () => {\n            const userData: User = {\n                username: \"testuser\",\n                password: \"testpassword\",\n                isActive: true\n            };\n\n            jest.spyOn(userModel, 'updateOne').mockResolvedValueOnce(userData as any);\n\n            const updatedUser = await userModel.updateOne(userData);\n\n            expect(updatedUser).toEqual(userData);\n            expect(userModel.updateOne).toHaveBeenCalledWith(userData);\n        });\n    });\n\n    describe(\"Unhappy Flow\", () => {\n        it(\"should throw an error when missing username\", async () => {\t\n            const userData = {\n                password: \"testpassword\",\n                isActive: true\n            };\n\n            jest.spyOn(userModel, 'create').mockRejectedValueOnce(new Error(\"Username is required\"));\n\n            await expect(userModel.create(userData)).rejects.toThrow(\"Username is required\");\n            expect(userModel.create).toHaveBeenCalledWith(userData);\n        });\n\n        it(\"should throw an error when missing password\", async () => {\t\n            const userData = {\n                username: \"testuser\",\n                isActive: true\n            };\n\n            jest.spyOn(userModel, 'create').mockRejectedValueOnce(new Error(\"Password is required\"));\n\n            await expect(userModel.create(userData)).rejects.toThrow(\"Password is required\");\n            expect(userModel.create).toHaveBeenCalledWith(userData);\n        });\n\n        it(\"should throw an error when creating a user with an existing username\", async () => {\n            const user1: User = {\n                username: \"testuser\",\n                password: \"testpassword\",\n                isActive: true\n            };\n            \n            const user2: User = {\n                username: \"testuser\",\n                password: \"testpassword2\",\n                isActive: true\n            };\n\n            jest.spyOn(userModel, 'create').mockResolvedValueOnce(user1 as any);\n            jest.spyOn(userModel, 'create').mockRejectedValueOnce(new Error(\"Username already exists\"));\n\n            await userModel.create(user1);\n            await expect(userModel.create(user2)).rejects.toThrow(\"Username already exists\");\n            expect(userModel.create).toHaveBeenCalledWith(user1);\n            expect(userModel.create).toHaveBeenCalledWith(user2);\n        });\n    });\n});","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\users\\schemas\\user.schema.ts",["325"],[],"import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\nimport { HydratedDocument, Document, Types } from 'mongoose';\n\nexport type UserDocument = HydratedDocument<User>;\n\n@Schema()\nexport class User {\n    _id?: Types.ObjectId;\n\n    @Prop({ required: true, unique: true })\n    username: string;\n\n    @Prop({ required: true, select: false })\n    password: string;\n\n    @Prop({ default: true })\n    isActive?: boolean;\n};\n\nexport const UserSchema = SchemaFactory.createForClass(User);","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\users\\users.controller.spec.ts",["326","327"],[],"import { TestingModule, Test } from \"@nestjs/testing\";\nimport { UsersController } from './users.controller';\nimport { UsersService } from \"./users.service\";\n\ndescribe('UsersController', () => {\n    let controller: UsersController;\n    let usersService: UsersService;\n    const users = [];\n\n    beforeEach(async () => {\n      const module: TestingModule = await Test.createTestingModule({\n        controllers: [UsersController],\n        providers: [\n          {\n            provide: UsersService,\n            useValue: {\n              create: jest.fn(),\n              findAll: jest.fn(),\n              findOne: jest.fn(),\n              update: jest.fn(),\n              remove: jest.fn()\n            }\n          }\n        ]\n      }).compile();\n  \n      controller = module.get<UsersController>(UsersController);\n      usersService = module.get<UsersService>(UsersService);\n    });\n  \n    it('should be defined', () => {\n      expect(controller).toBeDefined();\n    });\n});\n","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\users\\users.controller.ts",["328","329","330","331","332"],[],"import { Body, Controller, Post, HttpException, HttpStatus, Get, Put, NotFoundException, Delete, ValidationPipe, UnauthorizedException, Param } from '@nestjs/common';\nimport { UsersService } from './users.service';\n\nimport { CreateUserDto } from './dto/create-user.dto';\nimport { UpdateUserDto } from './dto/update-user.dto';\nimport { DeleteUserDto } from './dto/delete-user.dto';\n\nimport { User } from './schemas/user.schema';\nimport { ApiCreatedResponse, ApiNotFoundResponse, ApiOkResponse, ApiParam, ApiTags, ApiUnauthorizedResponse, ApiUnprocessableEntityResponse } from '@nestjs/swagger';\n\n@ApiTags('users')\n@Controller('users')\nexport class UsersController {\n    constructor(private readonly usersService: UsersService) {}\n\n    @Post()\n    @ApiCreatedResponse({ description: 'The user has been successfully created.'})\n    @ApiUnprocessableEntityResponse({ description: 'Unable to create user.'})\n    create(@Body(new ValidationPipe()) createUserDto: CreateUserDto): Promise<{ mongoUser: User, neoUser: any }> {\n        return this.usersService\n            .create(createUserDto)\n            .then(user => user)\n            .catch(error => {\n                throw new HttpException('Unable to create user', HttpStatus.UNPROCESSABLE_ENTITY);\n            });\n    };\n\n    @Get()\n    @ApiOkResponse({ description: 'The users have been successfully retrieved.'})\n    @ApiNotFoundResponse({ description: 'Users not found.'})\n    findAll(): Promise<User[]> {\n        return this.usersService\n            .findAll()\n            .then(users => users)\n            .catch(error => {\n                throw new HttpException('Users not found', HttpStatus.NOT_FOUND);\n            });\n    };\n\n    @Get(':id')\n    @ApiParam({ name: 'id', type: String, description: 'The id of the user to retrieve.' })\n    @ApiOkResponse({ description: 'The user has been successfully retrieved.'})\n    @ApiNotFoundResponse({ description: 'User not found'})\n    findOne(@Param('id') id: string): Promise<User> {\n        return this.usersService\n            .findOne(id)\n            .then(user => user)\n            .catch(error => {\n                throw new HttpException('User not found', HttpStatus.NOT_FOUND);\n            });\n    };\n\n    @Put(':id')\n    @ApiParam({ name: 'id', type: String, description: 'The id of the user to update.' })\n    @ApiOkResponse({ description: 'The user has been successfully updated.'})\n    @ApiNotFoundResponse({ description: 'User not found'})\n    @ApiUnauthorizedResponse({ description: 'Current password is incorrect'})\n    @ApiUnprocessableEntityResponse({ description: 'Unable to update user'})\n    update(@Body(new ValidationPipe()) updateUserDto: UpdateUserDto, @Param('id') id: string): Promise<User> {\n        return this.usersService\n            .update(id, updateUserDto)\n            .then(user => user)\n            .catch(error => {\n                if (error instanceof NotFoundException) {\n                    throw new HttpException('User not found', HttpStatus.NOT_FOUND);\n                }\n\n                if (error instanceof UnauthorizedException) {\n                    throw new HttpException('Current password is incorrect', HttpStatus.UNAUTHORIZED);\n                }\n\n                throw new HttpException('Unable to update user', HttpStatus.UNPROCESSABLE_ENTITY);\n            });\n    };\n\n    @Delete(':id')\n    @ApiParam({ name: 'id', type: String, description: 'The id of the user to delete.' })\n    @ApiOkResponse({ description: 'The user has been successfully deleted.'})\n    @ApiNotFoundResponse({ description: 'User not found'})\n    @ApiUnprocessableEntityResponse({ description: 'Unable to delete user'})\n    remove(@Body(new ValidationPipe()) deleteUserDTO: DeleteUserDto, @Param('id') id: string): Promise<{ mongoUser: User, neoUser: any }> {\n        return this.usersService\n            .delete(id, deleteUserDTO)\n            .then(user => user)\n            .catch(error => {\n                if (error instanceof NotFoundException) {\n                    throw new HttpException('User not found', HttpStatus.NOT_FOUND);\n                }\n\n                if (error instanceof UnauthorizedException) {\n                    throw new HttpException('Password is incorrect', HttpStatus.UNAUTHORIZED);\n                }\n\n                throw new HttpException('Unable to delete user', HttpStatus.UNPROCESSABLE_ENTITY);\n            });\n    };\n}\n","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\users\\users.module.ts",[],[],"C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\users\\users.service.spec.ts",["333"],[],"import { Test, TestingModule } from '@nestjs/testing';\nimport { UsersService } from './users.service';\nimport { Model } from 'mongoose';\nimport { UserDocument } from './schemas/user.schema';\nimport { AppModule } from '../app.module';\nimport { getModelToken } from '@nestjs/mongoose';\n\ndescribe('UsersService', () => {\n  let service: UsersService;\n  let userModel: Model<UserDocument>;\n  let userID: any;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      imports: [AppModule]\n    }).compile();\n\n    service = module.get<UsersService>(UsersService);\n    userModel = module.get<Model<UserDocument>>(getModelToken('User'));\n\n    await userModel.deleteMany({});\n\n    const u = await userModel.create({\n      username: 'test',\n      password: 'test',\n      isActive: true\n    });\n\n    userID = u._id;\n\n    await userModel.create({\n      username: 'test2',\n      password: 'test2',\n      isActive: true\n    });\n\n    await userModel.create({\n      username: 'test3',\n      password: 'test3',\n      isActive: true\n    });\n\n    await userModel.create({\n      username: 'test4',\n      password: 'test4',\n      isActive: true\n    });\n  });\n\n  afterAll(async () => {\n    await userModel.deleteMany({});\n  });\n\n  it('should be defined', () => {\n    expect(service).toBeDefined();\n  });\n\n  describe('findAll', () => {\n    it('should return an array of users', async () => {\n      const res = await service.findAll();\n      expect(res).toBeInstanceOf(Array);\n      expect(res.length).toEqual(4);\n    });\n  });\n\n  describe('findOne', () => {\n    it('should return a user', async () => {\n      const res = await service.findOne(userID);\n      expect(res).toBeInstanceOf(Object);\n      expect(res.username).toEqual('test');\n    });\n\n    it('should throw an error when user is not found', async () => {\n      await expect(service.findOne('123')).rejects.toThrow();\n    });\n\n    it('should throw an error when user is not active', async () => {\n      await userModel.updateOne({ _id: userID }, { isActive: false });\n      await expect(service.findOne(userID)).rejects.toThrow();\n    });\n  });\n\n  describe('update', () => {\n    it('should update a user', async () => {\n      const res = await service.update(userID, { currentPassword: 'test', newPassword: 'test2' });\n      expect(res).toBeInstanceOf(Object);\n      expect(res.username).toEqual('test');\n      expect(res.password).toEqual('test2');\n    });\n\n    it('should throw an error when user is not found', async () => {\n      await expect(service.update('123', { currentPassword: 'test', newPassword: 'test2' })).rejects.toThrow();\n    });\n  });\n\n  describe('delete', () => {\n    it('should delete a user', async () => {\n      const res = await service.delete(userID, { password: 'test' });\n      expect(res).toBeInstanceOf(Object);\n      expect(res.mongoUser).toBeInstanceOf(Object);\n      expect(res.neoUser).toBeInstanceOf(Object);\n    });\n\n    it('should throw an error when user is not found', async () => {\n      await expect(service.delete('123', { password: 'test' })).rejects.toThrow();\n    });\n\n    it('should throw an error when password is incorrect', async () => {\n      await expect(service.delete(userID, { password: 'test2' })).rejects.toThrow();\n    });\n  });\n});\n","C:\\Users\\stanb\\Desktop\\School\\Nosql\\NoSQL_Studdit\\studdit\\apps\\studdit\\src\\app\\users\\users.service.ts",["334","335"],[],"import { Injectable, NotFoundException, UnauthorizedException } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { User } from './schemas/user.schema';\nimport { Model } from 'mongoose';\n\nimport { CreateUserDto } from './dto/create-user.dto';\nimport { UpdateUserDto } from './dto/update-user.dto';\nimport { DeleteUserDto } from './dto/delete-user.dto';\nimport { Neo4jService } from '../neo4j/neo4j.service';\n\n@Injectable()\nexport class UsersService {\n    constructor(\n        @InjectModel(User.name) private userModel: Model<User>,\n        private readonly neo4jService: Neo4jService\n    ) {}\n\n    private async userExists(username: string) {\n        const user = await this.userModel.findOne({ username });\n        return !!user;\n    }\n\n    async create(createUserDto: CreateUserDto): Promise<{ mongoUser: User, neoUser: any }> {\n        const neo = this.neo4jService.beginTransaction();\n        \n        const session = await this.userModel.db.startSession();\n        session.startTransaction();\n\n        try {\n            const userExists = await this.userExists(createUserDto.username);\n\n            if (userExists) {\n                const user = await this.userModel.findOne({ username: createUserDto.username });\n                user.isActive = true;\n                await user.save({ session });\n\n                const neoResult = await neo.run(\n                    `MATCH (u:User {username: $username}) SET u.isActive = true RETURN u`,\n                    { username: createUserDto.username }\n                );\n\n                await neo.commit();\n                await session.commitTransaction();\n\n                return {\n                    mongoUser: user,\n                    neoUser: {\n                        ...neoResult.records[0].get('u').properties,\n                        _id: neoResult.records[0].get('u').identity.low\n                    }\n                };\n            }\n\n            const createdUser = await this.userModel.create([createUserDto], { session });\n\n            const neoResult = await neo.run(\n                `CREATE (u:User {username: $username, isActive: $isActive}) RETURN u`,\n                { username: createUserDto.username, isActive: true }\n            );\n\n            await neo.commit();\n            await session.commitTransaction();\n\n            return {\n                mongoUser: createdUser[0],\n                neoUser: {\n                    ...neoResult.records[0].get('u').properties,\n                    _id: neoResult.records[0].get('u').identity.low\n                }\n            }\n        } catch (error) {\n            await neo.rollback();\n            await session.abortTransaction();\n            throw error;\n        } finally {\n            session.endSession();\n        }\n    }\n\n    async findAll(): Promise<User[]> {\n        try {\n            return this.userModel.find({ isActive: true });\n        } catch (error) {\n            throw new NotFoundException('Users not found');\n        }\n    }\n\n    async findOne(id: string): Promise<User> {\n        try {\n            const user = await this.userModel.findOne({ _id: id, isActive: true });\n\n            if (!user) {\n                throw new NotFoundException('User not found');\n            }\n\n            return user;\n        } catch (error) {\n            throw new NotFoundException('User not found');\n        }\n    }\n\n    async delete(id: string, deleteUserDTO: DeleteUserDto): Promise<{ mongoUser: User, neoUser: any }> {\n        const session = await this.userModel.startSession();\n        session.startTransaction();\n        const neo = this.neo4jService.beginTransaction();\n\n        try {\n            const user = await this.userModel.findOne({ _id: id }).select('+password').session(session);\n\n            if (!user) {\n                throw new NotFoundException('User not found');\n            }\n\n            if (deleteUserDTO.password !== user.password) {\n                throw new UnauthorizedException('Password is incorrect');\n            }\n\n            user.isActive = false;\n\n            await user.save({ session });\n\n            const neoResult = await neo.run(\n                `MATCH (u:User {username: $username}) SET u.isActive = false`,\n                { username: user.username }\n            );\n\n            await session.commitTransaction();\n            await neo.commit();\n\n            return {\n                mongoUser: user,\n                neoUser: neoResult\n            };\n        } catch (error) {\n            await session.abortTransaction();\n            await neo.rollback();\n\n            throw error;\n        } finally {\n            session.endSession();\n        }\n    }\n\n    async update(id: string, updateUserDto: UpdateUserDto): Promise<User> {\n        const session = await this.userModel.startSession();\n        session.startTransaction();\n\n        try {\n            const user = await this.userModel.findOne({ _id: id }).select('+password').session(session);\n            \n            if (!user) {\n                throw new NotFoundException('User not found');\n            }            \n\n            if (updateUserDto.currentPassword !== user.password) {\n                throw new UnauthorizedException('Current password is incorrect');\n            }\n\n            user.password = updateUserDto.newPassword;\n            await user.save({ session });\n\n            await session.commitTransaction();\n\n            return user;\n        } catch (error) {\n            await session.abortTransaction();\n            throw error;\n        } finally {\n            session.endSession();\n        }\n    }\n}\n",{"ruleId":"336","severity":1,"message":"337","line":4,"column":10,"nodeType":"338","messageId":"339","endLine":4,"endColumn":23},{"ruleId":"336","severity":1,"message":"340","line":5,"column":10,"nodeType":"338","messageId":"339","endLine":5,"endColumn":15},{"ruleId":"336","severity":1,"message":"341","line":7,"column":10,"nodeType":"338","messageId":"339","endLine":7,"endColumn":16},{"ruleId":"336","severity":1,"message":"342","line":8,"column":10,"nodeType":"338","messageId":"339","endLine":8,"endColumn":14},{"ruleId":"336","severity":1,"message":"343","line":9,"column":10,"nodeType":"338","messageId":"339","endLine":9,"endColumn":17},{"ruleId":"336","severity":1,"message":"344","line":13,"column":7,"nodeType":"338","messageId":"339","endLine":13,"endColumn":39},{"ruleId":"345","severity":1,"message":"346","line":56,"column":49,"nodeType":"347","messageId":"348","endLine":56,"endColumn":52,"suggestions":"349"},{"ruleId":"336","severity":1,"message":"350","line":141,"column":20,"nodeType":"338","messageId":"339","endLine":141,"endColumn":25},{"ruleId":"345","severity":1,"message":"346","line":33,"column":85,"nodeType":"347","messageId":"348","endLine":33,"endColumn":88,"suggestions":"351"},{"ruleId":"345","severity":1,"message":"346","line":67,"column":63,"nodeType":"347","messageId":"348","endLine":67,"endColumn":66,"suggestions":"352"},{"ruleId":"336","severity":1,"message":"337","line":4,"column":10,"nodeType":"338","messageId":"339","endLine":4,"endColumn":23},{"ruleId":"336","severity":1,"message":"340","line":5,"column":10,"nodeType":"338","messageId":"339","endLine":5,"endColumn":15},{"ruleId":"336","severity":1,"message":"342","line":7,"column":10,"nodeType":"338","messageId":"339","endLine":7,"endColumn":14},{"ruleId":"336","severity":1,"message":"353","line":11,"column":7,"nodeType":"338","messageId":"339","endLine":11,"endColumn":37},{"ruleId":"345","severity":1,"message":"346","line":16,"column":106,"nodeType":"347","messageId":"348","endLine":16,"endColumn":109,"suggestions":"354"},{"ruleId":"345","severity":1,"message":"346","line":32,"column":106,"nodeType":"347","messageId":"348","endLine":32,"endColumn":109,"suggestions":"355"},{"ruleId":"336","severity":1,"message":"356","line":4,"column":10,"nodeType":"338","messageId":"339","endLine":4,"endColumn":15},{"ruleId":"345","severity":1,"message":"346","line":23,"column":76,"nodeType":"347","messageId":"348","endLine":23,"endColumn":79,"suggestions":"357"},{"ruleId":"345","severity":1,"message":"346","line":73,"column":78,"nodeType":"347","messageId":"348","endLine":73,"endColumn":81,"suggestions":"358"},{"ruleId":"345","severity":1,"message":"346","line":12,"column":18,"nodeType":"347","messageId":"348","endLine":12,"endColumn":21,"suggestions":"359"},{"ruleId":"345","severity":1,"message":"346","line":12,"column":28,"nodeType":"347","messageId":"348","endLine":12,"endColumn":31,"suggestions":"360"},{"ruleId":"345","severity":1,"message":"346","line":12,"column":30,"nodeType":"347","messageId":"348","endLine":12,"endColumn":33,"suggestions":"361"},{"ruleId":"345","severity":1,"message":"346","line":33,"column":19,"nodeType":"347","messageId":"348","endLine":33,"endColumn":22,"suggestions":"362"},{"ruleId":"345","severity":1,"message":"346","line":43,"column":29,"nodeType":"347","messageId":"348","endLine":43,"endColumn":32,"suggestions":"363"},{"ruleId":"345","severity":1,"message":"346","line":12,"column":73,"nodeType":"347","messageId":"348","endLine":12,"endColumn":76,"suggestions":"364"},{"ruleId":"345","severity":1,"message":"346","line":54,"column":23,"nodeType":"347","messageId":"348","endLine":54,"endColumn":26,"suggestions":"365"},{"ruleId":"336","severity":1,"message":"366","line":1,"column":10,"nodeType":"338","messageId":"339","endLine":1,"endColumn":14},{"ruleId":"336","severity":1,"message":"367","line":1,"column":16,"nodeType":"338","messageId":"339","endLine":1,"endColumn":29},{"ruleId":"336","severity":1,"message":"368","line":2,"column":10,"nodeType":"338","messageId":"339","endLine":2,"endColumn":22},{"ruleId":"345","severity":1,"message":"346","line":36,"column":50,"nodeType":"347","messageId":"348","endLine":36,"endColumn":53,"suggestions":"369"},{"ruleId":"345","severity":1,"message":"346","line":45,"column":51,"nodeType":"347","messageId":"348","endLine":45,"endColumn":54,"suggestions":"370"},{"ruleId":"345","severity":1,"message":"346","line":34,"column":83,"nodeType":"347","messageId":"348","endLine":34,"endColumn":86,"suggestions":"371"},{"ruleId":"345","severity":1,"message":"346","line":65,"column":90,"nodeType":"347","messageId":"348","endLine":65,"endColumn":93,"suggestions":"372"},{"ruleId":"345","severity":1,"message":"346","line":68,"column":101,"nodeType":"347","messageId":"348","endLine":68,"endColumn":104,"suggestions":"373"},{"ruleId":"345","severity":1,"message":"346","line":87,"column":18,"nodeType":"347","messageId":"348","endLine":87,"endColumn":21,"suggestions":"374"},{"ruleId":"345","severity":1,"message":"346","line":96,"column":127,"nodeType":"347","messageId":"348","endLine":96,"endColumn":130,"suggestions":"375"},{"ruleId":"345","severity":1,"message":"346","line":130,"column":67,"nodeType":"347","messageId":"348","endLine":130,"endColumn":70,"suggestions":"376"},{"ruleId":"345","severity":1,"message":"346","line":131,"column":59,"nodeType":"347","messageId":"348","endLine":131,"endColumn":62,"suggestions":"377"},{"ruleId":"336","severity":1,"message":"378","line":2,"column":28,"nodeType":"338","messageId":"339","endLine":2,"endColumn":36},{"ruleId":"336","severity":1,"message":"337","line":4,"column":10,"nodeType":"338","messageId":"339","endLine":4,"endColumn":23},{"ruleId":"336","severity":1,"message":"340","line":5,"column":10,"nodeType":"338","messageId":"339","endLine":5,"endColumn":15},{"ruleId":"336","severity":1,"message":"342","line":7,"column":10,"nodeType":"338","messageId":"339","endLine":7,"endColumn":14},{"ruleId":"336","severity":1,"message":"341","line":8,"column":10,"nodeType":"338","messageId":"339","endLine":8,"endColumn":16},{"ruleId":"336","severity":1,"message":"343","line":9,"column":10,"nodeType":"338","messageId":"339","endLine":9,"endColumn":17},{"ruleId":"336","severity":1,"message":"379","line":13,"column":7,"nodeType":"338","messageId":"339","endLine":13,"endColumn":37},{"ruleId":"345","severity":1,"message":"346","line":56,"column":49,"nodeType":"347","messageId":"348","endLine":56,"endColumn":52,"suggestions":"380"},{"ruleId":"345","severity":1,"message":"346","line":82,"column":51,"nodeType":"347","messageId":"348","endLine":82,"endColumn":54,"suggestions":"381"},{"ruleId":"345","severity":1,"message":"346","line":107,"column":49,"nodeType":"347","messageId":"348","endLine":107,"endColumn":52,"suggestions":"382"},{"ruleId":"336","severity":1,"message":"383","line":1,"column":31,"nodeType":"338","messageId":"339","endLine":1,"endColumn":37},{"ruleId":"336","severity":1,"message":"384","line":7,"column":10,"nodeType":"338","messageId":"339","endLine":7,"endColumn":23},{"ruleId":"336","severity":1,"message":"385","line":3,"column":30,"nodeType":"338","messageId":"339","endLine":3,"endColumn":40},{"ruleId":"345","severity":1,"message":"346","line":34,"column":79,"nodeType":"347","messageId":"348","endLine":34,"endColumn":82,"suggestions":"386"},{"ruleId":"345","severity":1,"message":"346","line":48,"column":79,"nodeType":"347","messageId":"348","endLine":48,"endColumn":82,"suggestions":"387"},{"ruleId":"345","severity":1,"message":"346","line":63,"column":82,"nodeType":"347","messageId":"348","endLine":63,"endColumn":85,"suggestions":"388"},{"ruleId":"345","severity":1,"message":"346","line":110,"column":76,"nodeType":"347","messageId":"348","endLine":110,"endColumn":79,"suggestions":"389"},{"ruleId":"336","severity":1,"message":"378","line":2,"column":28,"nodeType":"338","messageId":"339","endLine":2,"endColumn":36},{"ruleId":"336","severity":1,"message":"390","line":7,"column":9,"nodeType":"338","messageId":"339","endLine":7,"endColumn":35},{"ruleId":"336","severity":1,"message":"391","line":8,"column":11,"nodeType":"338","messageId":"339","endLine":8,"endColumn":16},{"ruleId":"345","severity":1,"message":"346","line":19,"column":107,"nodeType":"347","messageId":"348","endLine":19,"endColumn":110,"suggestions":"392"},{"ruleId":"336","severity":1,"message":"350","line":23,"column":20,"nodeType":"338","messageId":"339","endLine":23,"endColumn":25},{"ruleId":"336","severity":1,"message":"350","line":35,"column":20,"nodeType":"338","messageId":"339","endLine":35,"endColumn":25},{"ruleId":"336","severity":1,"message":"350","line":48,"column":20,"nodeType":"338","messageId":"339","endLine":48,"endColumn":25},{"ruleId":"345","severity":1,"message":"346","line":81,"column":132,"nodeType":"347","messageId":"348","endLine":81,"endColumn":135,"suggestions":"393"},{"ruleId":"345","severity":1,"message":"346","line":11,"column":15,"nodeType":"347","messageId":"348","endLine":11,"endColumn":18,"suggestions":"394"},{"ruleId":"345","severity":1,"message":"346","line":23,"column":85,"nodeType":"347","messageId":"348","endLine":23,"endColumn":88,"suggestions":"395"},{"ruleId":"345","severity":1,"message":"346","line":102,"column":97,"nodeType":"347","messageId":"348","endLine":102,"endColumn":100,"suggestions":"396"},"@typescript-eslint/no-unused-vars","'getModelToken' is defined but never used.","Identifier","unusedVar","'Model' is defined but never used.","'Thread' is defined but never used.","'User' is defined but never used.","'Comment' is defined but never used.","'commentsService' is assigned a value but never used.","@typescript-eslint/no-explicit-any","Unexpected any. Specify a different type.","TSAnyKeyword","unexpectedAny",["397","398"],"'error' is defined but never used.",["399","400"],["401","402"],"'friendsService' is assigned a value but never used.",["403","404"],["405","406"],"'Types' is defined but never used.",["407","408"],["409","410"],["411","412"],["413","414"],["415","416"],["417","418"],["419","420"],["421","422"],["423","424"],"'Test' is defined but never used.","'TestingModule' is defined but never used.","'Neo4jService' is defined but never used.",["425","426"],["427","428"],["429","430"],["431","432"],["433","434"],["435","436"],["437","438"],["439","440"],["441","442"],"'Document' is defined but never used.","'threadsService' is assigned a value but never used.",["443","444"],["445","446"],["447","448"],"'Inject' is defined but never used.","'NotFoundError' is defined but never used.","'UserSchema' is defined but never used.",["449","450"],["451","452"],["453","454"],["455","456"],"'usersService' is assigned a value but never used.","'users' is assigned a value but never used.",["457","458"],["459","460"],["461","462"],["463","464"],["465","466"],{"messageId":"467","fix":"468","desc":"469"},{"messageId":"470","fix":"471","desc":"472"},{"messageId":"467","fix":"473","desc":"469"},{"messageId":"470","fix":"474","desc":"472"},{"messageId":"467","fix":"475","desc":"469"},{"messageId":"470","fix":"476","desc":"472"},{"messageId":"467","fix":"477","desc":"469"},{"messageId":"470","fix":"478","desc":"472"},{"messageId":"467","fix":"479","desc":"469"},{"messageId":"470","fix":"480","desc":"472"},{"messageId":"467","fix":"481","desc":"469"},{"messageId":"470","fix":"482","desc":"472"},{"messageId":"467","fix":"483","desc":"469"},{"messageId":"470","fix":"484","desc":"472"},{"messageId":"467","fix":"485","desc":"469"},{"messageId":"470","fix":"486","desc":"472"},{"messageId":"467","fix":"487","desc":"469"},{"messageId":"470","fix":"488","desc":"472"},{"messageId":"467","fix":"489","desc":"469"},{"messageId":"470","fix":"490","desc":"472"},{"messageId":"467","fix":"491","desc":"469"},{"messageId":"470","fix":"492","desc":"472"},{"messageId":"467","fix":"493","desc":"469"},{"messageId":"470","fix":"494","desc":"472"},{"messageId":"467","fix":"495","desc":"469"},{"messageId":"470","fix":"496","desc":"472"},{"messageId":"467","fix":"497","desc":"469"},{"messageId":"470","fix":"498","desc":"472"},{"messageId":"467","fix":"499","desc":"469"},{"messageId":"470","fix":"500","desc":"472"},{"messageId":"467","fix":"501","desc":"469"},{"messageId":"470","fix":"502","desc":"472"},{"messageId":"467","fix":"503","desc":"469"},{"messageId":"470","fix":"504","desc":"472"},{"messageId":"467","fix":"505","desc":"469"},{"messageId":"470","fix":"506","desc":"472"},{"messageId":"467","fix":"507","desc":"469"},{"messageId":"470","fix":"508","desc":"472"},{"messageId":"467","fix":"509","desc":"469"},{"messageId":"470","fix":"510","desc":"472"},{"messageId":"467","fix":"511","desc":"469"},{"messageId":"470","fix":"512","desc":"472"},{"messageId":"467","fix":"513","desc":"469"},{"messageId":"470","fix":"514","desc":"472"},{"messageId":"467","fix":"515","desc":"469"},{"messageId":"470","fix":"516","desc":"472"},{"messageId":"467","fix":"517","desc":"469"},{"messageId":"470","fix":"518","desc":"472"},{"messageId":"467","fix":"519","desc":"469"},{"messageId":"470","fix":"520","desc":"472"},{"messageId":"467","fix":"521","desc":"469"},{"messageId":"470","fix":"522","desc":"472"},{"messageId":"467","fix":"523","desc":"469"},{"messageId":"470","fix":"524","desc":"472"},{"messageId":"467","fix":"525","desc":"469"},{"messageId":"470","fix":"526","desc":"472"},{"messageId":"467","fix":"527","desc":"469"},{"messageId":"470","fix":"528","desc":"472"},{"messageId":"467","fix":"529","desc":"469"},{"messageId":"470","fix":"530","desc":"472"},{"messageId":"467","fix":"531","desc":"469"},{"messageId":"470","fix":"532","desc":"472"},{"messageId":"467","fix":"533","desc":"469"},{"messageId":"470","fix":"534","desc":"472"},{"messageId":"467","fix":"535","desc":"469"},{"messageId":"470","fix":"536","desc":"472"},{"messageId":"467","fix":"537","desc":"469"},{"messageId":"470","fix":"538","desc":"472"},{"messageId":"467","fix":"539","desc":"469"},{"messageId":"470","fix":"540","desc":"472"},"suggestUnknown",{"range":"541","text":"542"},"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct.","suggestNever",{"range":"543","text":"544"},"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of.",{"range":"545","text":"542"},{"range":"546","text":"544"},{"range":"547","text":"542"},{"range":"548","text":"544"},{"range":"549","text":"542"},{"range":"550","text":"544"},{"range":"551","text":"542"},{"range":"552","text":"544"},{"range":"553","text":"542"},{"range":"554","text":"544"},{"range":"555","text":"542"},{"range":"556","text":"544"},{"range":"557","text":"542"},{"range":"558","text":"544"},{"range":"559","text":"542"},{"range":"560","text":"544"},{"range":"561","text":"542"},{"range":"562","text":"544"},{"range":"563","text":"542"},{"range":"564","text":"544"},{"range":"565","text":"542"},{"range":"566","text":"544"},{"range":"567","text":"542"},{"range":"568","text":"544"},{"range":"569","text":"542"},{"range":"570","text":"544"},{"range":"571","text":"542"},{"range":"572","text":"544"},{"range":"573","text":"542"},{"range":"574","text":"544"},{"range":"575","text":"542"},{"range":"576","text":"544"},{"range":"577","text":"542"},{"range":"578","text":"544"},{"range":"579","text":"542"},{"range":"580","text":"544"},{"range":"581","text":"542"},{"range":"582","text":"544"},{"range":"583","text":"542"},{"range":"584","text":"544"},{"range":"585","text":"542"},{"range":"586","text":"544"},{"range":"587","text":"542"},{"range":"588","text":"544"},{"range":"589","text":"542"},{"range":"590","text":"544"},{"range":"591","text":"542"},{"range":"592","text":"544"},{"range":"593","text":"542"},{"range":"594","text":"544"},{"range":"595","text":"542"},{"range":"596","text":"544"},{"range":"597","text":"542"},{"range":"598","text":"544"},{"range":"599","text":"542"},{"range":"600","text":"544"},{"range":"601","text":"542"},{"range":"602","text":"544"},{"range":"603","text":"542"},{"range":"604","text":"544"},{"range":"605","text":"542"},{"range":"606","text":"544"},{"range":"607","text":"542"},{"range":"608","text":"544"},{"range":"609","text":"542"},{"range":"610","text":"544"},{"range":"611","text":"542"},{"range":"612","text":"544"},[2957,2960],"unknown",[2957,2960],"never",[1059,1062],[1059,1062],[2588,2591],[2588,2591],[856,859],[856,859],[1614,1617],[1614,1617],[706,709],[706,709],[2382,2385],[2382,2385],[370,373],[370,373],[380,383],[380,383],[437,440],[437,440],[935,938],[935,938],[1174,1177],[1174,1177],[493,496],[493,496],[1383,1386],[1383,1386],[1032,1035],[1032,1035],[1425,1428],[1425,1428],[1092,1095],[1092,1095],[2368,2371],[2368,2371],[2555,2558],[2555,2558],[3428,3431],[3428,3431],[3895,3898],[3895,3898],[5491,5494],[5491,5494],[5577,5580],[5577,5580],[2816,2819],[2816,2819],[3990,3993],[3990,3993],[5085,5088],[5085,5088],[1042,1045],[1042,1045],[1537,1540],[1537,1540],[2052,2055],[2052,2055],[3757,3760],[3757,3760],[1009,1012],[1009,1012],[3776,3779],[3776,3779],[399,402],[399,402],[850,853],[850,853],[3462,3465],[3462,3465]]